{"version":3,"sources":["Board.js","index.js"],"names":["initialGrid","height","width","Array","fill","map","x","totalAliveNeighbors","cell","grid","neighbors","findingNeighbors","isAlive","checkForAlive","bind","filter","length","checkRangeForNegativeNumbers","neighbour","size","possibleNeighbors","validNeighbors","predicate","checkGreaterThanBoard","boardSize","set1","set2","resultSet","rowIndex","columnIndex","push","cartesian","Board","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","board","state","bounds","topLeft","bottomRight","time","e","_e$target$id$split","target","id","split","_e$target$id$split2","slicedToArray","rowId","colId","slice","setState","_this2","timerId","setInterval","initialWorld","nextWorld","index","i","noOfAliveNeighbours","nextState","generateNextWorld","clearInterval","_this3","row","columns","col","className","react_default","a","createElement","onClick","makeCellLive","generateTable","start","stop","React","Component","ReactDOM","render","src_Board","document","getElementById"],"mappings":"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","file":"static/js/main.8c492692.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./index.css\";\n\nconst initialGrid = function(height, width) {\n  let grid = new Array(width).fill(height).map(x => new Array(x).fill(0));\n  return grid;\n};\n\nconst totalAliveNeighbors = function(cell, grid) {\n  let neighbors = findingNeighbors([16, 16], cell);\n  let isAlive = checkForAlive.bind(null, grid);\n  let aliveNeighbor = neighbors.filter(isAlive);\n  return aliveNeighbor.length;\n};\n\nconst checkRangeForNegativeNumbers = function(cell) {\n  return cell[0] >= 0 && cell[1] >= 0;\n};\n\nconst predicate = function(cell, neighbour) {\n  return !(cell[0] === neighbour[0] && cell[1] === neighbour[1]);\n};\n\nconst isCoordinatesGreaterThanBoard = function(boardSize, cell) {\n  return cell[0] < boardSize[0] && cell[1] < boardSize[1];\n};\n\nconst checkForAlive = function(grid, neighbour) {\n  return grid[neighbour[0]][neighbour[1]] !== 0;\n};\n\nconst cartesian = function(set1, set2) {\n  let resultSet = [];\n  for (let rowIndex = 0; rowIndex < set1.length; rowIndex++) {\n    for (let columnIndex = 0; columnIndex < set2.length; columnIndex++) {\n      resultSet.push([set1[rowIndex], set2[columnIndex]]);\n    }\n  }\n  return resultSet;\n};\n\nconst validNeighbors = function(possibleNeighbors, cell, size) {\n  let validNeighbors = possibleNeighbors.filter(neighbour =>\n    predicate(cell, neighbour)\n  );\n  validNeighbors = validNeighbors.filter(checkRangeForNegativeNumbers);\n  let checkGreaterThanBoard = isCoordinatesGreaterThanBoard.bind(null, size);\n  validNeighbors = validNeighbors.filter(checkGreaterThanBoard);\n  return validNeighbors;\n};\n\nconst findingNeighbors = function(size, cell) {\n  let rowCoordinates = [cell[0] - 1, cell[0], cell[0] + 1];\n  let coloumnCoordinates = [cell[1] - 1, cell[1], cell[1] + 1];\n  let possibleNeighbors = cartesian(rowCoordinates, coloumnCoordinates);\n  let neighbors = validNeighbors(possibleNeighbors, cell, size);\n\n  return neighbors;\n};\n\nconst checkForNextGenration = function(currentCellState, neighbourLength) {\n  let rules = [0, 0, currentCellState, 1, 0, 0, 0, 0, 0];\n  return rules[neighbourLength];\n};\n\nconst generateNextWorld = function(initialWorld) {\n  let nextWorld = initialWorld.map(x => x.slice());\n  for (let index = 0; index < initialWorld.length; index++) {\n    for (let i = 0; i < initialWorld[0].length; i++) {\n      let noOfAliveNeighbours = totalAliveNeighbors([index, i], initialWorld);\n      let nextState = checkForNextGenration(\n        initialWorld[index][i],\n        noOfAliveNeighbours\n      );\n      nextWorld[index][i] = nextState;\n    }\n  }\n  return nextWorld;\n};\n\nclass Board extends React.Component {\n  constructor(props) {\n    super(props);\n    this.size = +props.size;\n    const board = initialGrid(this.size + 1, this.size + 1);\n    this.state = {\n      board,\n      bounds: { topLeft: 0, bottomRight: this.size + 1 }\n    };\n    this.time = 1000;\n  }\n\n  makeCellLive(e) {\n    const [rowId, colId] = e.target.id.split(\"_\");\n    const board = this.state.board.slice();\n    board[rowId][colId] = 1 - board[rowId][colId];\n\n    this.setState({ board });\n  }\n\n  start() {\n    this.timerId = setInterval(() => {\n      const board = generateNextWorld(this.state.board);\n      this.setState({ board });\n    }, this.time);\n  }\n\n  stop(){\n    clearInterval(this.timerId);\n  }\n\n  generateTable() {\n    return this.state.board.map((row, rowId) => {\n      const columns = row.map((col, colId) => {\n        let className = \"alive\";\n        if (col === 0) {\n          className = \"dead\";\n        }\n        const id = rowId + \"_\" + colId;\n        return (\n          <td\n            id={id}\n            className={className}\n            onClick={this.makeCellLive.bind(this)}\n          />\n        );\n      });\n      return <tr>{columns}</tr>;\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <table>\n          <tbody>{this.generateTable()}</tbody>\n        </table>\n        <button onClick={this.start.bind(this)}>start</button>\n        <button onClick={this.stop.bind(this)}>stop</button>\n      </div>\n    );\n  }\n}\n\nexport default Board;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Board from \"./Board\";\nimport \"./index.css\";\n\nReactDOM.render(<Board size=\"15\" />, document.getElementById(\"root\"));\n"],"sourceRoot":""}