{"version":3,"sources":["Board.js","index.js"],"names":["initialGrid","height","width","Array","fill","map","x","totalAliveNeighbors","cell","grid","neighbors","findingNeighbors","isAlive","checkForAlive","bind","filter","length","checkRangeForNegativeNumbers","neighbour","size","possibleNeighbors","validNeighbors","predicate","checkGreaterThanBoard","boardSize","set1","set2","resultSet","rowIndex","columnIndex","push","cartesian","Board","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","board","state","bounds","topLeft","bottomRight","e","_e$target$id$split","target","id","split","_e$target$id$split2","slicedToArray","rowId","colId","slice","setState","_this2","timerId","setInterval","initialWorld","nextWorld","index","i","noOfAliveNeighbours","nextState","generateNextWorld","console","log","_this3","row","columns","col","className","react_default","a","createElement","onClick","makeCellLive","generateTable","start","React","Component","ReactDOM","render","src_Board","document","getElementById"],"mappings":"kNAGMA,QAAc,SAASC,EAAQC,GAEnC,OADW,IAAIC,MAAMD,GAAOE,KAAKH,GAAQI,IAAI,SAAAC,GAAC,OAAI,IAAIH,MAAMG,GAAGF,KAAK,OAIhEG,EAAsB,SAASC,EAAMC,GACzC,IAAIC,EAAYC,EAAiB,CAAC,GAAI,IAAKH,GACvCI,EAAUC,EAAcC,KAAK,KAAML,GAEvC,OADoBC,EAAUK,OAAOH,GAChBI,QAGjBC,EAA+B,SAAST,GAC5C,OAAOA,EAAK,IAAM,GAAKA,EAAK,IAAM,GAW9BK,EAAgB,SAASJ,EAAMS,GACnC,OAA4C,IAArCT,EAAKS,EAAU,IAAIA,EAAU,KAuBhCP,EAAmB,SAASQ,EAAMX,GAMtC,OAhBqB,SAASY,EAAmBZ,EAAMW,GACvD,IAAIE,EAAiBD,EAAkBL,OAAO,SAAAG,GAAS,OAvBvC,SAASV,EAAMU,GAC/B,QAASV,EAAK,KAAOU,EAAU,IAAMV,EAAK,KAAOU,EAAU,IAuBzDI,CAAUd,EAAMU,KAElBG,EAAiBA,EAAeN,OAAOE,GACvC,IAAIM,EAvBgC,SAASC,EAAWhB,GACxD,OAAOA,EAAK,GAAKgB,EAAU,IAAMhB,EAAK,GAAKgB,EAAU,IAsBKV,KAAK,KAAMK,GAErE,OADAE,EAAiBA,EAAeN,OAAOQ,GAChCF,EAOSA,CAxBA,SAASI,EAAMC,GAE/B,IADA,IAAIC,EAAY,GACPC,EAAW,EAAGA,EAAWH,EAAKT,OAAQY,IAC7C,IAAK,IAAIC,EAAc,EAAGA,EAAcH,EAAKV,OAAQa,IACnDF,EAAUG,KAAK,CAACL,EAAKG,GAAWF,EAAKG,KAGzC,OAAOF,EAgBiBI,CAFH,CAACvB,EAAK,GAAK,EAAGA,EAAK,GAAIA,EAAK,GAAK,GAC7B,CAACA,EAAK,GAAK,EAAGA,EAAK,GAAIA,EAAK,GAAK,IAERA,EAAMW,IAqF3Ca,cA3Db,SAAAA,EAAYC,GAAO,IAAAC,EAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,IACjBE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,KAAMJ,KACDd,MAAQc,EAAMd,KACnB,IAAMsB,EAAQzC,EAAYkC,EAAKf,KAAO,EAAGe,EAAKf,KAAO,GAHpC,OAIjBe,EAAKQ,MAAQ,CACXD,QACAE,OAAQ,CAAEC,QAAS,EAAGC,YAAaX,EAAKf,KAAO,IANhCe,4EAUNY,GAAG,IAAAC,EACSD,EAAEE,OAAOC,GAAGC,MAAM,KAD3BC,EAAAhB,OAAAiB,EAAA,EAAAjB,CAAAY,EAAA,GACPM,EADOF,EAAA,GACAG,EADAH,EAAA,GAERV,EAAQJ,KAAKK,MAAMD,MAAMc,QAC/Bd,EAAMY,GAAOC,GAAS,EAAIb,EAAMY,GAAOC,GAEvCjB,KAAKmB,SAAS,CAAEf,0CAGV,IAAAgB,EAAApB,KACNA,KAAKqB,QAAUC,YAAY,WACzB,IAAMlB,EApCc,SAASmB,GAEjC,IADA,IAAIC,EAAYD,EAAavD,IAAI,SAAAC,GAAC,OAAIA,EAAEiD,UAC/BO,EAAQ,EAAGA,EAAQF,EAAa5C,OAAQ8C,IAC/C,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAa,GAAG5C,OAAQ+C,IAAK,CAC/C,IAAIC,EAAsBzD,EAAoB,CAACuD,EAAOC,GAAIH,GACtDK,EATI,CAAC,EAAG,EAUVL,EAAaE,GAAOC,GAVW,EAAG,EAAG,EAAG,EAAG,EAAG,GAW9CC,GAEFH,EAAUC,GAAOC,GAAKE,EAG1B,OAAOJ,EAwBWK,CAAkBT,EAAKf,MAAMD,OAC3C0B,QAAQC,IAAI3B,GACZgB,EAAKD,SAAS,CAAEf,WACf,6CAGW,IAAA4B,EAAAhC,KACd,OAAOA,KAAKK,MAAMD,MAAMpC,IAAI,SAACiE,EAAKjB,GAChC,IAAMkB,EAAUD,EAAIjE,IAAI,SAACmE,EAAKlB,GAC5B,IAAImB,EAAY,QACJ,IAARD,IACFC,EAAY,QAEd,IAAMxB,EAAKI,EAAQ,IAAMC,EACzB,OACEoB,EAAAC,EAAAC,cAAA,MACE3B,GAAIA,EACJwB,UAAWA,EACXI,QAASR,EAAKS,aAAahE,KAAKuD,OAItC,OAAOK,EAAAC,EAAAC,cAAA,UAAKL,sCAKd,OACEG,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAAA,aACEF,EAAAC,EAAAC,cAAA,aAAQvC,KAAK0C,kBAEfL,EAAAC,EAAAC,cAAA,UAAQC,QAASxC,KAAK2C,MAAMlE,KAAKuB,OAAjC,SACAqC,EAAAC,EAAAC,cAAA,8BAtDYK,IAAMC,WC3E1BC,IAASC,OAAOV,EAAAC,EAAAC,cAACS,EAAD,CAAOlE,KAAK,OAAQmE,SAASC,eAAe","file":"static/js/main.236bb5fc.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./index.css\";\n\nconst initialGrid = function(height, width) {\n  let grid = new Array(width).fill(height).map(x => new Array(x).fill(0));\n  return grid;\n};\n\nconst totalAliveNeighbors = function(cell, grid) {\n  let neighbors = findingNeighbors([11, 11], cell);\n  let isAlive = checkForAlive.bind(null, grid);\n  let aliveNeighbor = neighbors.filter(isAlive);\n  return aliveNeighbor.length;\n};\n\nconst checkRangeForNegativeNumbers = function(cell) {\n  return cell[0] >= 0 && cell[1] >= 0;\n};\n\nconst predicate = function(cell, neighbour) {\n  return !(cell[0] === neighbour[0] && cell[1] === neighbour[1]);\n};\n\nconst isCoordinatesGreaterThanBoard = function(boardSize, cell) {\n  return cell[0] < boardSize[0] && cell[1] < boardSize[1];\n};\n\nconst checkForAlive = function(grid, neighbour) {\n  return grid[neighbour[0]][neighbour[1]] !== 0;\n};\n\nconst cartesian = function(set1, set2) {\n  let resultSet = [];\n  for (let rowIndex = 0; rowIndex < set1.length; rowIndex++) {\n    for (let columnIndex = 0; columnIndex < set2.length; columnIndex++) {\n      resultSet.push([set1[rowIndex], set2[columnIndex]]);\n    }\n  }\n  return resultSet;\n};\n\nconst validNeighbors = function(possibleNeighbors, cell, size) {\n  let validNeighbors = possibleNeighbors.filter(neighbour =>\n    predicate(cell, neighbour)\n  );\n  validNeighbors = validNeighbors.filter(checkRangeForNegativeNumbers);\n  let checkGreaterThanBoard = isCoordinatesGreaterThanBoard.bind(null, size);\n  validNeighbors = validNeighbors.filter(checkGreaterThanBoard);\n  return validNeighbors;\n};\n\nconst findingNeighbors = function(size, cell) {\n  let rowCoordinates = [cell[0] - 1, cell[0], cell[0] + 1];\n  let coloumnCoordinates = [cell[1] - 1, cell[1], cell[1] + 1];\n  let possibleNeighbors = cartesian(rowCoordinates, coloumnCoordinates);\n  let neighbors = validNeighbors(possibleNeighbors, cell, size);\n\n  return neighbors;\n};\n\nconst checkForNextGenration = function(currentCellState, neighbourLength) {\n  let rules = [0, 0, currentCellState, 1, 0, 0, 0, 0, 0];\n  return rules[neighbourLength];\n};\n\nconst generateNextWorld = function(initialWorld) {\n  let nextWorld = initialWorld.map(x => x.slice());\n  for (let index = 0; index < initialWorld.length; index++) {\n    for (let i = 0; i < initialWorld[0].length; i++) {\n      let noOfAliveNeighbours = totalAliveNeighbors([index, i], initialWorld);\n      let nextState = checkForNextGenration(\n        initialWorld[index][i],\n        noOfAliveNeighbours\n      );\n      nextWorld[index][i] = nextState;\n    }\n  }\n  return nextWorld;\n};\n\nclass Board extends React.Component {\n  constructor(props) {\n    super(props);\n    this.size = +props.size;\n    const board = initialGrid(this.size + 1, this.size + 1);\n    this.state = {\n      board,\n      bounds: { topLeft: 0, bottomRight: this.size + 1 }\n    };\n  }\n\n  makeCellLive(e) {\n    const [rowId, colId] = e.target.id.split(\"_\");\n    const board = this.state.board.slice();\n    board[rowId][colId] = 1 - board[rowId][colId];\n\n    this.setState({ board });\n  }\n\n  start() {\n    this.timerId = setInterval(() => {\n      const board = generateNextWorld(this.state.board);\n      console.log(board);\n      this.setState({ board });\n    }, 1000);\n  }\n\n  generateTable() {\n    return this.state.board.map((row, rowId) => {\n      const columns = row.map((col, colId) => {\n        let className = \"alive\";\n        if (col === 0) {\n          className = \"dead\";\n        }\n        const id = rowId + \"_\" + colId;\n        return (\n          <td\n            id={id}\n            className={className}\n            onClick={this.makeCellLive.bind(this)}\n          />\n        );\n      });\n      return <tr>{columns}</tr>;\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <table>\n          <tbody>{this.generateTable()}</tbody>\n        </table>\n        <button onClick={this.start.bind(this)}>start</button>\n        <button>stop</button>\n      </div>\n    );\n  }\n}\n\nexport default Board;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Board from \"./Board\";\nimport \"./index.css\";\n\nReactDOM.render(<Board size=\"10\"/>, document.getElementById(\"root\"));\n"],"sourceRoot":""}